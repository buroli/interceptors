import { HTTP } from '@/helpers/http'
import { store } from '@/store/'
import { router } from '@/router/'

let pendingRequest = 0;
let isRefreshing = false;
let failedQueue = [];

const processQueue = (error, token = null) => {
  failedQueue.forEach(prom => {
    if (error) {
      prom.reject(error);
    } else {
      prom.resolve(token);
    }
  });

  failedQueue = [];
};

export default function interceptor () {


  // request INTERCEPTOR
  HTTP.interceptors.request.use(function (config) {
    if(config.method === 'put' || (config.url !== 'Account/login' && config.method === 'post')){
      pendingRequest++;
      store.dispatch('addAutoSaveNotification', true)
    }
    return config
  });

  HTTP.interceptors.response.use(response => {
    pendingRequest--;
    // hide autoSaveNotification if not pending request
    if(pendingRequest <= 0){
      store.dispatch('addAutoSaveNotification', false)
    }

    return Promise.resolve(response)
  }, err => {

    const error = err.response;
    const originalRequest = error.config;
    const isRememberMe = store.state.auth.rememberMe;

    if (error.status === 400 && originalRequest && !originalRequest.__isRetryRequest) {
      pendingRequest--;
      // hide autoSaveNotification if not pending request
      if(pendingRequest <= 0){
        store.dispatch('addAutoSaveNotification', false)
      }
      // show error on bad request
      if(error.data.errors.length > 1) {
        store.dispatch('addErrors', error.data.errors.map(e => e.message))
      } else {
        store.dispatch('addError', error.data.errors[0].message)
      }

      // prevent autoSave looping on error
      if( store.state.notifications.autoSaveNotification ){
        store.commit('ADD_AUTO_SAVE_NOTIFICATION_STATUS', 'error')
      }
    }

    if (error.status === 401 && originalRequest && !originalRequest.__isRetryRequest) {
        if (isRefreshing) {
          return new Promise(function(resolve, reject) {
            // put waiting call to queue
            failedQueue.push({resolve, reject});
          }).then(token => {
            // set headers Authorization for when first call is resolved
            originalRequest.headers['Authorization'] = `Bearer ${token}`;
            return HTTP.request(originalRequest);
          }).catch(err => {
            return Promise.reject(err);
          })
        }

        originalRequest._retry = true;
        isRefreshing = true;

        const connectionData = {
          grantType: 'RefreshToken',
          refreshToken: store.state.auth.refreshToken
        };

        // on the first 401 error, call login to get new token and refresh token
        return new Promise((resolve, reject) => {
          if(isRememberMe && !!connectionData.refreshToken){
            HTTP.post('Account/login', connectionData)
              .then(response => {
                // store token, refresh token
                store.commit('AUTH_SUCCESS', response.data.datas);
                // add new token to header
                HTTP.defaults.headers.common['Authorization'] = `Bearer ${response.data.datas.accessToken}`;
                // add new token to others pending request
                originalRequest.headers['Authorization'] = `Bearer ${response.data.datas.accessToken}`;
                processQueue(null, response.data.datas.accessToken);
                resolve(HTTP(originalRequest));
            })
              .catch(error => {
                processQueue(error, null);
                delete HTTP.defaults.headers.common['Authorization'];
                store.dispatch('resetState', {}, {root: true});
                // as there is an error, set isRefreshing to false to prevent call with a wrong refreshToken
                // it happens when we connect to local and staging. As there is only one refreshToken generated by account.
                isRefreshing = false;
                reject(error);
            })
              .finally(() => {
                isRefreshing = false;
            });
          } else {
            store.dispatch('addNotification', { type: 'info', value: `Session expired. Redirecting to login page...`});

            // wait a little bit to show message to user
            setTimeout(() => {
              store.dispatch('resetState', {}, {root: true});
              router.push('/login')
            }, 3000);
          }
        })
    }

    return Promise.reject(err)
  });
}
